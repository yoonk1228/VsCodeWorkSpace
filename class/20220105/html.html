<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
        /* 2중 for문 */
        for (let i=0; i<10; i++) {
            console.log(i)
            for (let j=0; j<10; j++) {
                console.log("값은",i,j)
            }
        }

        for (let i=0; i<10; i++) {
            let star = "*"
            for (let j=0; j<3; j++) {
                star += "*"
            }
            console.log(star)
            console.log("")
        }

        for (let i=1; i<10; i++) {
            console.log("2*"+i+"="+(2*i))
        }

        for (let i=1; i<10; i++) {
            console.log()
        }

        function guguclass(num) {
            for(let i=1; i<10; i++) {
                console.log(num+"*"+i+"="+i*num)
            }
        }

        guguclass(8)

        //2단~9단까지를 한번에 출력
        for(let i=2; i<10; i++) {
            for(let j=1; j<0; j++) {
                console.log(i+"*"+j+"="+i*j)
            }
        }

        /* 스택구조 (자료구조) */
        let arr = []
        for (let i=1; i<101; i++) {
            arr.push(i)
        }
        console.log(arr)

        // 배열 안에서 100이라는 숫자를 찾아보자
        for (let i=0; i<arr.length; i++) {
            if (arr[i] == 100) {
                console.log(i+1)
            }
        }

        // 자료구조 스택(LIFO), 큐

        /*
            시간 복잡도
            작업을 수행할때 컴퓨터가 얼마나 많은 시간이 걸리느냐

        */
        console.time()
        let num = 0;
        for (let i=1; i<1001; i++) {
            num += i
        }
        console.log(num) // 500500
        console.timeEnd() // 0.042ms

        console.time()
        let n = 1000;
        console.log(n*(n+1)/2) // 500500
        console.timeEnd() // 0.025ms

        // 재귀함수(FIFO)
        /*
            구조적으로 개념이 완전 다르다.
            자기자신을 함수로 부른다.
            비동기를 하기 위해 필요함.
        */
        console.log('test');
        console.time()
        function yoon(n) {
            if (n <= 1) {
                console.log('마지막 스택 n은 ' + n)
                return 1 //
                //
            }
            let answer = yoon(n-1)
            console.log('n은 ' + n);
            console.log(n+answer)
            return n + answer // 함수 안에서 함수를 호출한 형태.
            //
        }
        // console.log(yoon(100)) // 5050
        console.log(yoon(5)) // 15
        console.log('test end');
        console.timeEnd() // 0.04ms

        // 피보나치 수열
        /*
            다이내믹 프로그래밍

        */
        function fibo(n) {
            if(n == 1 || n ==2) {
               return 1
            }
            console.log('hello')
        }
        // fibo(1) //
        // fibo(2) //
        fibo(3) // hello

        function fibo2(n) {
            if(n == 1 || n ==2) {
                return 1
            }
            return fibo2(n-1) + fibo2(n-2) // 3넣을시 fibo2 스택이 두개쌓임 (1과 2)
        }
        // 시간 복잡도가 n의2 승만큼 콜스택을 차지하는 문제가 생김. (무거워진다)
        console.log(fibo2(3)) // 2
        console.log(fibo2(10)) // 10
        // console.log(fibo2(50)) // 엄청 오래걸림

        //메모이제이션 react .useMemo .useCallback

        let number = [1,1]; // 계산할 결과값을 저장할 공간
        // 1,1 첫번째 원소값은 1이고, 두번째 원소값도 1이다.
        function fibo3(n) {
            // 내가 가지고있는 원소중에서 첫번째원소와 두번째 원소를 리턴해주는것 부터 만들자.
            if (number[n-1] > 0) {
                return 1
            } else if (number[n-1] > 0) {
                return number[n-1]
            } else {
                return fibo3(n-1) + fibo3(n-2)
            }
        }
        // 시간 복잡도가 n의 1승 (n) 만큼 콜스택을 차지하게 된다.
        console.time()
        console.log(fibo3(10)) // 55
        console.timeEnd() // 0.05ms
        console.time()
        console.log(fibo3(20)) // 6765
        console.timeEnd() // 10.2ms
        console.time()
        console.log(fibo3(40)) // 102334155
        console.timeEnd() // 1078.ms
    </script>
</head>
<body>

</body>
</html>